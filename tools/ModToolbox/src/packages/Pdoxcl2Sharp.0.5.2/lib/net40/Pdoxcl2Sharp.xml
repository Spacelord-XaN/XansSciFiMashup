<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Pdoxcl2Sharp</name>
    </assembly>
    <members>
        <member name="M:Pdoxcl2Sharp.Deserializer.Parse(System.Type)">
            <summary>
            Creates a function that will create an object of a given type when given a parser
            </summary>
            <param name="type">THe type to be deserialized</param>
            <returns>The function to create <typeparamref name="type"/> from a parser</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.Deserializer.MakeMethod(System.String,System.Object[],System.Type[])">
            <summary>
            Creates and invokes a function that will create a function to
            deserialize a parser into an object. This is needed as we don't know
            all the types we'll be working with and so we create functions as
            need be.
            </summary>
            <param name="name">The name of the function to create</param>
            <param name="parameters">The parameters to be passed to the created function</param>
            <param name="typeArguments">The types which are used to fill in the
            generic arguments of the newly created function</param>
            <returns>A function used to deserialize an object from a parser</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.Deserializer.ParsePrimitive``1">
            <summary>
            If <typeparamref name="T"/> is a primitive that is supported
            (Null-able included), the function to parse a primitive of the type
            is created. There are some primitives that don't have a logical
            mapping such as <see cref="T:System.Char"/> and  <see cref="T:System.DBNull"/>. If
            <typeparamref name="T"/> isn't recognized then null is returned.
            </summary>
            <typeparam name="T">The type to be deserialized</typeparam>
            <returns>Function to create <typeparamref name="T"/> from parser</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.Globals.ToParadoxString(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> to a string that adheres to
            Paradox's own encodings
            </summary>
            <param name="date">Date to be converted into a string</param>
            <returns>The Paradox string representation of the date</returns>
        </member>
        <member name="T:Pdoxcl2Sharp.INamingConvention">
            <summary>
            Defines how to transform a given property name into the appropriate
            representation to be deserialized
            </summary>
        </member>
        <member name="T:Pdoxcl2Sharp.Plurality">
            <summary>
            Provides hint as to whether a word is singular, plural or with unknown plurality
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.Plurality.Singular">
            <summary>
            The word is singular
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.Plurality.Plural">
            <summary>
            The word is plural
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.Plurality.CouldBeEither">
            <summary>
            I am unsure of the plurality
            </summary>
        </member>
        <member name="T:Pdoxcl2Sharp.InflectorExtensions">
            <summary>
            Inflector extensions
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.InflectorExtensions.Pluralize(System.String,Pdoxcl2Sharp.Plurality)">
            <summary>
            Pluralizes the provided input considering irregular words
            </summary>
            <param name="word">Word to be pluralized</param>
            <param name="plurality">Normally you call Pluralize on singular words; but if you're unsure call it with Plurality.CouldBeEither</param>
            <returns></returns>
        </member>
        <member name="M:Pdoxcl2Sharp.InflectorExtensions.Singularize(System.String,Pdoxcl2Sharp.Plurality)">
            <summary>
            Singularizes the provided input considering irregular words
            </summary>
            <param name="word">Word to be singularized</param>
            <param name="plurality">Normally you call Singularize on plural words; but if you're unsure call it with Plurality.CouldBeEither</param>
            <returns></returns>
        </member>
        <member name="M:Pdoxcl2Sharp.InflectorExtensions.Pascalize(System.String)">
            <summary>
            By default, pascalize converts strings to UpperCamelCase also removing underscores
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Pdoxcl2Sharp.InflectorExtensions.Camelize(System.String)">
            <summary>
            Same as Pascalize except that the first character is lower case
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Pdoxcl2Sharp.InflectorExtensions.Underscore(System.String)">
            <summary>
            Separates the input words with underscore
            </summary>
            <param name="input">The string to be underscored</param>
            <returns></returns>
        </member>
        <member name="M:Pdoxcl2Sharp.InflectorExtensions.Dasherize(System.String)">
            <summary>
            Replaces underscores with dashes in the string
            </summary>
            <param name="underscoredWord"></param>
            <returns></returns>
        </member>
        <member name="M:Pdoxcl2Sharp.InflectorExtensions.Hyphenate(System.String)">
            <summary>
            Replaces underscores with hyphens in the string
            </summary>
            <param name="underscoredWord"></param>
            <returns></returns>
        </member>
        <member name="T:Pdoxcl2Sharp.IParadoxRead">
            <summary>
            Defines a common interface for parsing content in Paradox's format
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.IParadoxRead.TokenCallback(Pdoxcl2Sharp.ParadoxParser,System.String)">
            <summary>
            This function is invoked as a callback when the parser encounters
            a token and does not know how to handle it.
            </summary>
            <param name="parser">The parser that invoked the callback</param>
            <param name="token">The token that the parser didn't know how to handle</param>
        </member>
        <member name="T:Pdoxcl2Sharp.IParadoxWrite">
            <summary>
            Defines a class that can output its content in a format that 
            can be later used by Paradox
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.IParadoxWrite.Write(Pdoxcl2Sharp.ParadoxStreamWriter)">
            <summary>
            Outputs the class's contents to the writer.
            </summary>
            <param name="writer">Object to write the structure of the class</param>
        </member>
        <member name="T:Pdoxcl2Sharp.ParadoxAliasAttribute">
            <summary>
            Instructs the <see cref="T:Pdoxcl2Sharp.Deserializer"/> to use a different field name for serialization.
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxAliasAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Pdoxcl2Sharp.ParadoxAliasAttribute"/> class.
            </summary>
            <param name="alias">The alias to use for this field.</param>
        </member>
        <member name="P:Pdoxcl2Sharp.ParadoxAliasAttribute.Alias">
            <summary>
            Gets or sets the alias name.
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxCompressedSaver.NoNewLineIfQuoted(Pdoxcl2Sharp.ValueWrite)">
            <summary>
            If a value being written is quoted, then there is no need to insert
            a newline because quotes are used as delimiters
            </summary>
            <param name="val"><see cref="T:Pdoxcl2Sharp.ValueWrite"/> to test against</param>
            <returns>A new <see cref="T:Pdoxcl2Sharp.ValueWrite"/> that ensures delimitation</returns>
        </member>
        <member name="T:Pdoxcl2Sharp.ParadoxNamingConvention">
            <summary>
            Converts a string that contains uppercase letters to a string that
            contains only lowercase letters with an underscore prefixing the
            previously uppercase letters
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.ParadoxParser.MaxByteBuffer">
            <summary>
            The number of bytes that is desired to read at a time from the
            stream. 64 KB was chosen due to the paper: "Sequential File
            Programming Patterns and Performance with .NET" stating "A rule of
            thumb is that the minimum recommended transfer size is 64 KB and
            that bigger transfers are generally better." A bigger buffer wasn't
            chosen because performance boosts dropped dramatically after 64 KB.
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.ParadoxParser.BufferSize">
            <summary>
            The number of characters that will be processed at a time. This is
            capped at encoding level as there could be a possibility of the
            char buffer being bigger than the byte buffer (byte-wise).
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Pdoxcl2Sharp.ParadoxParser"/> class.
            Parses a stream and executes the parsing strategy when an unknown token is encountered.
            </summary>
            <param name="data">Stream to be parsed</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="data"/> is null</exception>
        </member>
        <member name="P:Pdoxcl2Sharp.ParadoxParser.CurrentIndent">
            <summary>
            Gets how many indents the current parser is at.  For instance if the parser read
            read two '{' but zero '}', the <see cref="P:Pdoxcl2Sharp.ParadoxParser.CurrentIndent"/> would be two.
            </summary>
        </member>
        <member name="P:Pdoxcl2Sharp.ParadoxParser.CurrentString">
            <summary>
            Gets the last string read by the parser
            </summary>
        </member>
        <member name="P:Pdoxcl2Sharp.ParadoxParser.EndOfStream">
            <summary>
            Gets a value indicating whether the parser is at the end of the stream
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.TryParseDate(System.String,System.DateTime@)">
            <summary>
            Converts the specified string representation of a date and time from
            Paradox's format of (year).(month).(day) and optionally (hour) to
            its <see cref="T:System.DateTime"/> equivalent, and returns a value that
            indicates whether the conversion succeeded. 
            </summary>
            <param name="dateTime">A string containing the date to parse.</param>
            <param name="result">
            When this method returns, contains the <see cref="T:System.DateTime"/> equivalent
            to the date and time contained in string parameter, if the conversion succeeded,
            or MinValue if the conversion failed.
            </param>
            <returns>True if the conversion was successful</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.IsSpace(System.Char)">
            <summary>
            Checks to see whether a given character is considered whitespace.
            </summary>
            <param name="c">The character to evaluate</param>
            <returns>True if <paramref name="c"/> is whitespace</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.Deserialize``1(System.IO.Stream)">
            <summary>
            Given a stream, the function will deserialize it into a
            specific type. 
            </summary>
            <typeparam name="T">The type to deserialize</typeparam>
            <param name="data">The stream to extract the object</param>
            <returns>The object deserialized from the stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.Parse(System.IO.Stream,System.Action{Pdoxcl2Sharp.ParadoxParser,System.String})">
            <summary>
            Parses a given stream and applies an action to each token found
            </summary>
            <param name="data">Stream to parse</param>
            <param name="parseStrategy">Action to be performed on found tokens</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.Parse``1(System.IO.Stream,``0)">
            <summary>
            Parses a given stream with a defined structure
            </summary>
            <param name="data">Stream to parse</param>
            <param name="entity">Defines how to parse the stream</param>
            <typeparam name="T">Type of the structure to be parsed</typeparam>
            <returns><paramref name="entity"/> in a fluent interface</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.Parse``1(``0)">
            <summary>
            Reads everything between same level brackets and parses it based on the 
            <paramref name="innerStructure"/>
            </summary>
            <param name="innerStructure">Defines how to parse the inner set of tokens.</param>
            <typeparam name="T">Type of the structure to parse</typeparam>
            <returns><paramref name="innerStructure"/> in a fluent interface</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.Parse(System.Action{Pdoxcl2Sharp.ParadoxParser,System.String})">
            <summary>
            Reads everything between same level brackets and applies the action to each token
            </summary>
            <param name="action">The action to be performed on each token</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadString">
            <summary>
            Reads a string from the current stream. String will be strictly composed of 
            <see cref="F:Pdoxcl2Sharp.LexerToken.Untyped"/>. If quotes are encountered in the stream then the return value
            will be the string that is contained within the quotes (the quotes are stripped)
            <see cref="P:Pdoxcl2Sharp.ParadoxParser.CurrentString"/> is set to the return value.
            </summary>
            <returns>The string being read</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadInt32">
            <summary>
            Reads a 4-byte signed integer from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the number
            </summary>
            <returns>A 4-byte signed integer read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadInt16">
            <summary>
            Reads a 2-byte signed integer from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the number
            </summary>
            <returns>A 2-byte signed integer read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadSByte">
            <summary>
            Reads a signed byte from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the number
            </summary>
            <returns>A signed byte read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadUInt32">
            <summary>
            Reads a 4-byte unsigned integer from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the number
            </summary>
            <returns>A 4-byte unsigned integer read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadUInt16">
            <summary>
            Reads a 2-byte unsigned integer from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the number
            </summary>
            <returns>A 2-byte unsigned integer read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadByte">
            <summary>
            Reads a byte from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the number
            </summary>
            <returns>A byte read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadBool">
            <summary>
            Reads a boolean from the current stream and advances the current position
            of the stream a variable amount depending on the string representation
            of the boolean
            </summary>
            <returns>A boolean read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadDouble">
            <summary>
            Reads a 8-byte floating point value from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the floating point
            </summary>
            <returns>An 8-byte floating point value read from the current stream.</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadFloat">
            <summary>
            Reads a 4-byte floating point value from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the floating point
            </summary>
            <returns>An 4-byte floating point value read from the current stream.</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadDateTime">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from the current stream and advances the current position
            of the stream a variable amount depending on the string representation of the date and time.
            </summary>
            <returns><see cref="T:System.DateTime"/> read from the current stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadIntList">
            <summary>
            Reads the data between brackets as integers
            </summary>
            <returns>A list of the data interpreted as integers</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadDoubleList">
            <summary>
            Reads the data between brackets as doubles
            </summary>
            <returns>A list of the data interpreted as doubles</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadStringList">
            <summary>
            Reads the data between brackets as strings
            </summary>
            <returns>A list of the data interpreted as strings</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadDateTimeList">
            <summary>
            Reads the data between brackets as DateTimes
            </summary>
            <returns>A list of the data interpreted as DateTimes</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadDictionary``2(System.Func{Pdoxcl2Sharp.ParadoxParser,``0},System.Func{Pdoxcl2Sharp.ParadoxParser,``1})">
            <summary>
            Extracts a dictionary from the data that is contained with brackets.
            It is assumed that key and value data will be separated by a token.
            It is also assumed that the key precedes the value definition.
            </summary>
            <example>
            extensions = 
            {
                .log = "log file"
                .txt = "text file"
            }
            </example>
            <typeparam name="TKey">Type of the key of the dictionary</typeparam>
            <typeparam name="TValue">Type of the value of the dictionary</typeparam>
            <param name="keyFunc">Function that when given the parser will extract a key</param>
            <param name="valueFunc">Function that when given the parser will extract a value</param>
            <returns>A dictionary that is populated from the data within brackets with the provided functions</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadInsideBrackets(System.Action{Pdoxcl2Sharp.ParadoxParser})">
            <summary>
            Advances the parser through the left bracket ('{') and then invokes the action.
            It is assumed that the action will consume only what is contained in the brackets.
            This function is useful when the number of data within brackets is known but may be of various types.
            </summary>
            <param name="action">An action that the parser will perform to extract data inside the curly brackets</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadList``1(System.Func{``0})">
            <summary>
            Parses the data between curly brackets in a manner dictated by the function parameter
            </summary>
            <typeparam name="T">Type that the data will be interpreted as</typeparam>
            <param name="func">Function that will extract the data</param>
            <returns>Data between curly brackets constructed as a list.</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.GetToken(System.Char)">
            <summary>
            Returns the <see cref="T:Pdoxcl2Sharp.LexerToken"/> representation of the parameter
            </summary>
            <param name="c">Character to be converted to associated token</param>
            <returns>The token associated with parameter</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.EnsureLeftCurly">
            <summary>
            Checks the current token, and if needed, reads next token in the
            stream in an attempt to locate a left curly.  If the token
            encountered is an equality symbol, it will read the next token and
            see if that is a left curly, e.g. x = { y }.  If the initial read
            token isn't an equality symbol or a left curly, or if the initial
            read token is an equality symbol but the subsequent token isn't a
            left curly, then an invalid operation exception is thrown.
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.DoWhileBracket(System.Action)">
            <summary>
            Executes an action while the matching closing right curly '}' is not met.
            If the action does not consume all the data inside the bracket content,
            the action is repeated.  Before the action is executed, the parser
            ensures parsing at the beginning of the data
            </summary>
            <remarks>
            Even if the action is blank, the function will protect against an infinite
            loop and will read until the end of the bracket content or if the end of 
            the file occurred, whichever one comes first.
            <para/>
            If the action doesn't advance the underlying stream, the stream will still
            advance as long as the loop conditional is true.  For the loop conditional to be
            true the current token or the next token can't be a right a curly.
            Since the action doesn't advance the stream it is guaranteed that current
            iteration's currentToken is the same value as the previous iteration's
            <see cref="M:Pdoxcl2Sharp.ParadoxParser.PeekToken"/> and <see cref="M:Pdoxcl2Sharp.ParadoxParser.PeekToken"/> token could not have been
            a right curly.  Therefore, if the action doesn't advance the stream,
            the current token will never be a right curly and <see cref="M:Pdoxcl2Sharp.ParadoxParser.PeekToken"/> will
            always be invoked. In short, <see cref="M:Pdoxcl2Sharp.ParadoxParser.PeekToken"/> advances the stream, so
            an infinite loop is impossible
            </remarks>
            <param name="act">The action that will be repeatedly performed while there is data left in the brackets</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.SetCurrentToken(System.Char)">
            <summary>
            Sets the current token to the token associated with the parameter
            </summary>
            <param name="c">Char that will be evaluated for equivalent token</param>
            <returns>Current token</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.SetCurrentToken(Pdoxcl2Sharp.LexerToken)">
            <summary>
            Evaluates the token parameter for brackets and sets the current
            token to it
            </summary>
            <param name="token">The token to be evaluated</param>
            <returns>The current token</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.GetNextToken">
            <summary>
            Advances the parser to the next significant token, skipping whitespace and
            comments.  If a left or right curly is encountered, the current indent is
            adjusted accordingly.
            </summary>
            <returns>The significant token encountered</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.PeekToken">
            <summary>
            Retrieves the next token, so that a subsequent call to <see cref="M:Pdoxcl2Sharp.ParadoxParser.GetNextToken"/>
            will return the same token.  If multiple peekTokens are invoked then it is the last
            token encountered that <see cref="M:Pdoxcl2Sharp.ParadoxParser.GetNextToken"/> will also return. The key
            difference between this function and <see cref="M:Pdoxcl2Sharp.ParadoxParser.GetNextToken"/> is that this
            function doesn't evaluate the new peeked token for brackets.
            <remarks>
                This function is a misnomer in the traditional sense the peek
                does not affect the underlying stream.  Though this function is
                prefixed with "peek", it advances the underlying stream.
            </remarks>
            </summary>
            <returns>The next token in the stream</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.NextIsBracketed">
            <summary>
            "Peeks" ahead of the current position to check if the previously read data
            is followed by a left bracket ('{'). Multiple calls without reading data will
            return the same value.
            <remarks>
                GetNextToken() should not be used, because it updates the state of the parser,
                which requires messy handling of indentation and ensuring the next token is
                a left curly.
            </remarks>
            </summary>
            <returns>Whether the current tag contains bracketed data.</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxParser.ReadNext">
            <summary>
            Retrieves the next char in the buffer, reading from the stream if necessary.  
            If the end of the stream was reached, the flag denoting it will be set.
            </summary>
            <returns>The next character in the buffer or '\0' if the end of the stream was reached</returns>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxSaver.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Pdoxcl2Sharp.ParadoxSaver"/> class with the specified <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="output">The stream that will be written to</param>
        </member>
        <member name="T:Pdoxcl2Sharp.ValueWrite">
            <summary>
            Options to control how something is written to a stream.  Different
            combinations of options can be created using bitwise operations. The
            exception is the None option.  
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.ValueWrite.None">
            <summary>
            Value is written to stream without any modification
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.ValueWrite.Quoted">
            <summary>
            Wrap the value to be written to the stream in quotes
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.ValueWrite.NewLine">
            <summary>
            After writing the value to stream, append a newline
            </summary>
        </member>
        <member name="F:Pdoxcl2Sharp.ValueWrite.LeadingTabs">
            <summary>
            Before writing the value to stream, prepend tabs such that the value
            written to stream matches the indent of surrounding values
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.String,System.String,Pdoxcl2Sharp.ValueWrite)">
            <summary>
            Writes a key-value pair to the stream with formatting specified by <paramref name="valuetype"/>.
            It is assumed that the key will be indented and that the value will not be.
            </summary>
            <param name="key">Key that identifies the value</param>
            <param name="value">Value to be written to the stream</param>
            <param name="valuetype">Dictates how the value should be written to the stream.</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String,Pdoxcl2Sharp.ValueWrite)">
            <summary>
            Writes a string in the format of <paramref name="valuetype"/> followed by a line terminator.
            </summary>
            <param name="value">The string to be written to the text stream</param>
            <param name="valuetype">The format of how the string should be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String,System.String,Pdoxcl2Sharp.ValueWrite)">
            <summary>
            Writes a key-value pair followed by a line terminator to the stream with formatting specified by <paramref name="valuetype"/>.
            It is assumed that the key will be indented and that the value will not be.
            </summary>
            <param name="key">Key that identifies the value</param>
            <param name="value">Value to be written to the stream</param>
            <param name="valuetype">Dictates how the value should be written to the stream</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String,System.DateTime)">
            <summary>
            Writes a date and time that is identified by a key.
            The date is written in a way to conform with how Paradox writes dates
            </summary>
            <param name="key">Key to be written</param>
            <param name="date">Date to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteComment(System.String)">
            <summary>
            Writes a string followed by a line terminator that will be ignored by a paradox parser
            </summary>
            <param name="comment">The string to be written to the file but ignored on parse</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.String,Pdoxcl2Sharp.IParadoxWrite)">
            <summary>
            Writes a structure that is identified by a header
            </summary>
            <param name="header">The string that will identify the following structure</param>
            <param name="obj">The <see cref="T:Pdoxcl2Sharp.IParadoxWrite"/> that dictates how the structure will be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.String,System.Action{Pdoxcl2Sharp.ParadoxStreamWriter})">
            <summary>
            Writes a structure that is identified by a header
            </summary>
            <param name="header">The string that will identify the following structure</param>
            <param name="objWriter">
            A function that accepts a <see cref="T:Pdoxcl2Sharp.ParadoxStreamWriter"/> 
            and dictates how the structure will be written
            </param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.String)">
            <summary>
            Writes a string
            </summary>
            <param name="value">String to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.Double)">
            <summary>
            Writes a double to the stream
            </summary>
            <param name="value">Double to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.Int32)">
            <summary>
            Writes an integer to the stream
            </summary>
            <param name="value">Integer to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.DateTime)">
            <summary>
            Writes a DateTime to the stream
            </summary>
            <param name="value">DateTime to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.String,System.String)">
            <summary>
            Writes a key-value pair to the stream with no special formatting
            </summary>
            <param name="key">Key that identifies the value</param>
            <param name="value">Value to be written to the stream</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String,System.String)">
            <summary>
            Writes a string value that is identified by a key followed by a line terminator
            </summary>
            <param name="key">The text can identify the value</param>
            <param name="value">Value to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String)">
            <summary>
            Writes a string followed by a line terminator to the text stream.
            </summary>
            <param name="value">The string to write. If value is null, only the line termination characters are written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine">
            <summary>
            Writes a line terminator to the text stream
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String,System.Boolean)">
            <summary>
            Writes a boolean that is identified by a key.
            The boolean is written in a way to conform with how Paradox writes booleans.
            </summary>
            <param name="key">Key to be written</param>
            <param name="val">Boolean to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String,System.Int32)">
            <summary>
            Writes an integer that is identified by a key.
            The integer is written in a way to conform with how Paradox writes integers.
            </summary>
            <param name="key">Key that identifies the value</param>
            <param name="val">Value to the be written to the stream</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.WriteLine(System.String,System.Double)">
            <summary>
            Writes a double that is a identified by a key.
            The double is written in a way to conform with how Paradox writes doubles.
            </summary>
            <param name="key">Key to be written.</param>
            <param name="val">Double to be written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Write(System.String,Pdoxcl2Sharp.ValueWrite)">
            <summary>
            Writes a string dictated by a format
            </summary>
            <param name="value">String to be written</param>
            <param name="type">Denotes what modifications to be made on the string before being written</param>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.Dispose">
            <summary>
            Releases all resources held by the writer
            </summary>
        </member>
        <member name="M:Pdoxcl2Sharp.ParadoxStreamWriter.UpdateCurrentIndentFromIndentsIn(System.String)">
            <summary>
            Given a string, the function will detect squirrely brackets and update
            the current indent of the writer
            </summary>
            <param name="str">String to be searched for squirrely brackets</param>
        </member>
    </members>
</doc>
