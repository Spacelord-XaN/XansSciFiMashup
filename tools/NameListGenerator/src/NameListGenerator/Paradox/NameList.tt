<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<# // CHANGE ME: The next line should be something like:
// $(SolutionDir)\vendor\Pdoxcl2Sharp.dll #>
<#@ assembly name="$(SolutionDir)\packages\Pdoxcl2Sharp.0.5.2\lib\net40\Pdoxcl2Sharp.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Pdoxcl2Sharp" #>  
<#@ output extension=".cs" #>
using System;
using Pdoxcl2Sharp;
using System.Collections.Generic;

namespace NameListGenerator.Paradox
{
<#

// Here is where you add any classes to be deserialized. Here is a tiny sample
// to get you started.

var classes = new[] {
    new {
        Name = "NameList",
        Props = new[] {
            new Property() { Type = "bool", Name = "Randomized" },
            new Property() { Type = "ShipNames", Name = "ShipNames", Alias = "ship_names" },
			new Property() { Type = "FleetNames", Name = "FleetNames", Alias = "fleet_names" },
			new Property() { Type = "ArmyNames", Name = "ArmyNames", Alias = "army_names" },
			new Property() { Type = "PlanetNames", Name = "PlanetNames", Alias = "planet_names" },
			new Property() { Type = "string", Name = "CharacterNames", Alias = "character_names" }
        }
    },
	new {
		Name = "ShipNames",
		Props = new[] {
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Generic", Alias = "generic" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Corvette", Alias = "corvette" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Constructor", Alias = "constructor" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Colonizer", Alias = "colonizer" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Science", Alias = "science" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Destroyer", Alias = "destroyer" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Cruiser", Alias = "cruiser" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Battleship", Alias = "battleship" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "OrbitalStation", Alias = "orbital_station" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "MiningStation", Alias = "mining_station" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "ResearchStation", Alias = "research_station" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "WormholeStation", Alias = "wormhole_station" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "TerraformStation", Alias = "terraform_station" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "ObservationStation", Alias = "observation_station" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "OutpostStation", Alias = "outpost_station" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "TransportStation", Alias = "transport" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "MilitaryStationSmall", Alias = "military_station_small" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "MilitaryStationMedium", Alias = "military_station_medium" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "MilitaryStationLarge", Alias = "military_station_large" }
		}
	},
    new {
        Name = "FleetNames",
        Props = new[] {
            new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "RandomNames", Alias = "random_names" },
			new Property() { Type = "string", Name = "SequentialName", Alias = "sequential_name" }
        }
    },
    new {
        Name = "ArmyNames",
        Props = new[] {
            new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Defense", Alias="defense_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Assault", Alias="assault_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Slave", Alias="slave_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Clone", Alias="clone_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Robotic", Alias="robotic_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Android", Alias="android_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Psionic", Alias="psionic_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Xenomorph", Alias="xenomorph_army" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "GeneWarrior", Alias="gene_warrior_army" }
        }
    },
    new {
        Name = "PlanetNames",
        Props = new[] {
            new Property() { Type = "PlanetClassNameList", Name = "Generic", Alias = "generic" },
			new Property() { Type = "PlanetClassNameList", Name = "Desert", Alias = "pc_desert" },
			new Property() { Type = "PlanetClassNameList", Name = "Arid", Alias = "pc_arid" },
			new Property() { Type = "PlanetClassNameList", Name = "Tropical", Alias = "pc_tropical" },
			new Property() { Type = "PlanetClassNameList", Name = "Continental", Alias = "pc_continental" },
			new Property() { Type = "PlanetClassNameList", Name = "Gaia", Alias = "pc_gaia" },
			new Property() { Type = "PlanetClassNameList", Name = "Ocean", Alias = "pc_ocean" },
			new Property() { Type = "PlanetClassNameList", Name = "Tundra", Alias = "pc_tundra" },
			new Property() { Type = "PlanetClassNameList", Name = "Arctic", Alias = "pc_arctic" }
        }
    },
	new {
		Name = "PlanetClassNameList",
		Props = new [] {
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "Names", Alias="names" }
		}
	},
	new {
		Name = "CharacterNameList",
		Props = new[] {
            new Property() { Type = "int", Name = "Weight", Alias = "weight" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "FirstNamesMale", Alias = "first_names_male" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "FirstNamesFemale", Alias = "first_names_female" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "SecondNames", Alias = "second_names" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "RegnalFirstNamesMale", Alias = "regnal_first_names_male" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "RegnalFirstNamesFemale", Alias = "regnal_first_names_female" },
			new Property() { Type = "[ConsecutiveElements] IList<string>", Name = "RegnalSecondNames", Alias = "regnal_second_names" }
        }
	}
};

// end add

INamingConvention naming = new ParadoxNamingConvention();
bool exhaustive = false;

var dict = new Dictionary<string, string>()
{
    { "int", "parser.ReadInt32()" },
    { "string", "parser.ReadString()" },
    { "bool", "parser.ReadBool()" },
    { "byte", "parser.ReadByte()" },
    { "DateTime", "parser.ReadDateTime()" },
    { "double", "parser.ReadDouble()" },
    { "short", "parser.ReadInt16()" },
    { "sbyte", "parser.ReadSByte()" },
    { "float", "parser.ReadFloat()" },
    { "ushort", "parser.ReadUInt16()" },
    { "uint", "parser.ReadUInt32()" },
    { "int?", "parser.ReadInt32()" },
    { "bool?", "parser.ReadBool()" },
    { "byte?", "parser.ReadByte()" },
    { "DateTime?", "parser.ReadDateTime()" },
    { "double?", "parser.ReadDouble()" },
    { "short?", "parser.ReadInt16()" },
    { "sbyte?", "parser.ReadSByte()" },
    { "float?", "parser.ReadFloat()" },
    { "ushort?", "parser.ReadUInt16()" },
    { "uint?", "parser.ReadUInt32()" },
    { "[ConsecutiveElements] IEnumerable<string>", "parser.ReadStringList()" },
    { "[ConsecutiveElements] ICollection<string>", "parser.ReadStringList()" },
    { "[ConsecutiveElements] IList<string>", "parser.ReadStringList()" },
    { "[ConsecutiveElements] List<string>", "parser.ReadStringList()" },
    { "[ConsecutiveElements] IEnumerable<int>", "parser.ReadIntList()" },
    { "[ConsecutiveElements] ICollection<int>", "parser.ReadIntList()" },
    { "[ConsecutiveElements] IList<int>", "parser.ReadIntList()" },
    { "[ConsecutiveElements] List<int>", "parser.ReadIntList()" },
    { "[ConsecutiveElements] IEnumerable<double>", "parser.ReadDoubleList()" },
    { "[ConsecutiveElements] ICollection<double>", "parser.ReadDoubleList()" },
    { "[ConsecutiveElements] IList<double>", "parser.ReadDoubleList()" },
    { "[ConsecutiveElements] List<double>", "parser.ReadDoubleList()" },
    { "[ConsecutiveElements] IEnumerable<DateTime>", "parser.ReadDateTimeList()" },
    { "[ConsecutiveElements] ICollection<DateTime>", "parser.ReadDateTimeList()" },
    { "[ConsecutiveElements] IList<DateTime>", "parser.ReadDateTimeList()" },
    { "[ConsecutiveElements] List<DateTime>", "parser.ReadDateTimeList()" }
};

foreach (var clazz in classes) { #>
    public partial class <#= clazz.Name #> : IParadoxRead, IParadoxWrite
    {
<# foreach (var prop in clazz.Props) { #>
        public <#= prop.Type.Replace("[ConsecutiveElements] ", "") #> <#= prop.Name #> { get; set; }
<# } #>

        public <#= clazz.Name #>()
        {
<#  var lists = clazz.Props.Where(x => x.IsNonConsecutiveList);
    foreach (var list in lists)
    {
        var str = list.ExtractInnerListType();
        WriteLine("            " + list.Name + " = new List<" + str + ">();");
    }#>
        }

        public void TokenCallback(ParadoxParser parser, string token)
        {
            switch (token)
            {
<#
        ClearIndent();
        PushIndent("            "); 
        foreach (var prop in clazz.Props) {
            Write("case " + '"');
            Write(prop.GetStr(naming));
            Write("\": ");
            
            string res;
            string fallback = "parser.Parse(new " + prop.Type + "())";
            if (dict.TryGetValue(prop.Type, out res))
                Write(prop.Name + " = " + res);
            else if (prop.IsNonConsecutiveList)
            {
                var str = prop.ExtractInnerListType();
                fallback = "parser.Parse(new " + str + "())";
                Write(prop.Name + ".Add(" + (dict.TryGetValue(str, out res)
                    ? res : fallback) + ")");
            }
            else if (prop.Type.Contains("[ConsecutiveElements]"))
                Write(prop.Name + " = parser.ReadList(() => parser.Parse " +
					"(new " + prop.ExtractInnerListType() + "()))");
            else
                Write(prop.Name + " = " + fallback);
            WriteLine("; break;");
        }

        if (exhaustive) {
            WriteLine("default: throw new ApplicationException(\"Unrecognized token: \" + token);");
        }
        
        WriteLine("}");
        ClearIndent();
         #>
        }

        public void Write(ParadoxStreamWriter writer)
        {
<#
        ClearIndent();
        PushIndent("            "); 
        foreach (var prop in clazz.Props) {
            var qStr = !prop.Quoted ? "" : ", ValueWrite.Quoted";

            // eg. nullables
            if (prop.Type.Contains('?')) {
                WriteLine("if (" + prop.Name + ".HasValue)");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("writer.WriteLine(\"" + prop.GetStr(naming) + "\", " + prop.Name + ".Value);");
                PopIndent();
                WriteLine("}");
            }

            // eg. List<string>, add_core
            else if (prop.IsNonConsecutiveList && dict.ContainsKey(prop.ExtractInnerListType())) {
                WriteLine("foreach(var val in " + prop.Name + ")");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("writer.WriteLine(\"" + prop.GetStr(naming) + "\", val" + qStr + ");");
                PopIndent();
                WriteLine("}");
            }
             
            // eg. List<Army>
            else if (prop.IsNonConsecutiveList && !dict.ContainsKey(prop.ExtractInnerListType())) {
                WriteLine("foreach(var val in " + prop.Name + ")");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("writer.Write(\"" + prop.GetStr(naming) + "\", val);");
                PopIndent();
                WriteLine("}");
            }

            // eg. string, int, etc
            else if (dict.ContainsKey(prop.Type) && !prop.Type.Contains("[ConsecutiveElements]")) {
                if (prop.Type == "string") {
                    WriteLine("if (" + prop.Name + " != null)");
                    WriteLine("{");
                    PushIndent("    ");
                }

                WriteLine("writer.WriteLine(\"" + prop.GetStr(naming) + "\", " + prop.Name + qStr + ");");

                if (prop.Type == "string") {
                    PopIndent();
                    WriteLine("}");
                }
            }

            // eg. List<string> { you me them }
            else if (dict.ContainsKey(prop.Type)) {
                WriteLine("if (" + prop.Name + " != null)");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("writer.Write(\"" + prop.GetStr(naming) + "={ \");");
                WriteLine("foreach (var val in " + prop.Name + ")");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("writer.Write(val" + qStr + ");");
                WriteLine("writer.Write(\" \");");
                PopIndent();
                WriteLine("}");
                WriteLine("writer.WriteLine(\"}\");");
                PopIndent();
                WriteLine("}");
            }

            else if (prop.Type.Contains("[ConsecutiveElements]")) {
                WriteLine("if (" + prop.Name + " != null)");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("writer.Write(\"" + prop.GetStr(naming) + "\", w =>");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("foreach (var val in " + prop.Name + ")");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("w.Write(String.Empty, val);");
                PopIndent();
                WriteLine("}");
                PopIndent();
                WriteLine("});");
                PopIndent();
                WriteLine("}");
            }

            else {
                WriteLine("if (" + prop.Name + " != null)");
                WriteLine("{");
                PushIndent("    ");
                WriteLine("writer.Write(\"" + prop.GetStr(naming) + "\", " + prop.Name + ");");
                PopIndent();
                WriteLine("}");
            }
        }

        ClearIndent();
    #>
        }
    }

<# } #>
}
